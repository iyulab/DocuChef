using System.Text.RegularExpressions;
using DocuChef.Presentation.Exceptions;
using DocuChef.Presentation.Models;
using DocuChef.Presentation.Utilities;
using DocumentFormat.OpenXml.Drawing;

namespace DocuChef.Presentation.Processors;

/// <summary>
/// Analyzes PowerPoint template slides to extract binding expressions and directives
/// </summary>
public class TemplateAnalyzer
{
    // Compiled regex patterns for performance optimization
    private static readonly Regex BindingExpressionRegex = new Regex(@"\$\{([^}]+)\}", RegexOptions.Compiled);
    private static readonly Regex ArrayIndexRegex = new Regex(@"(.+?)\[(\d+)\]", RegexOptions.Compiled);
    private static readonly Regex FormatSpecifierRegex = new Regex(@"(.+?)(?::(.+))?$", RegexOptions.Compiled);
    private static readonly Regex DirectiveRegex = new Regex(@"#(foreach|range|alias)\s*:\s*(.+)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    private static readonly Regex ConditionalRegex = new Regex(@"(.+?)\s*\?\s*(.+?)\s*:\s*(.+)", RegexOptions.Compiled);
    private static readonly Regex MethodCallRegex = new Regex(@"(.+)\(\)$", RegexOptions.Compiled);
    private static readonly Regex ForeachOptionsRegex = new Regex(@"(.+?)(?:,\s*max\s*:\s*(\d+))?(?:,\s*offset\s*:\s*(\d+))?$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    private static readonly Regex RangeOptionsRegex = new Regex(@"(?:(begin|end)\s*,\s*)?(.+)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    private static readonly Regex AliasOptionsRegex = new Regex(@"(.+?)\s+as\s+(.+)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    private static readonly Regex ContextOperatorRegex = new Regex(@"(.+?)>(.+)", RegexOptions.Compiled);

    /// <summary>
    /// Analyzes a slide and extracts its binding expressions and directives
    /// </summary>
    /// <param name="slide">The slide object to analyze</param>
    /// <param name="slideNotes">The notes content of the slide</param>
    /// <param name="slideId">The unique identifier of the slide</param>
    /// <returns>A SlideInfo object containing analysis results</returns>
    public SlideInfo Analyze(object slide, string slideNotes, int slideId)
    {
        var slideInfo = new SlideInfo
        {
            SlideId = slideId,
            Type = SlideType.Static
        };

        // Parse directives from slide notes
        if (!string.IsNullOrEmpty(slideNotes))
        {
            slideInfo.Directives = ParseSlideNotes(slideNotes);
        }        // Extract binding expressions from slide text using centralized extractor
        var bindingExpressions = ExpressionExtractor.ExtractExpressionsFromSlide(slide);
        var expressionsToProcess = bindingExpressions.ToList(); // Make a copy to avoid modification issues
        foreach (var expressionText in expressionsToProcess)
        {
            try
            {
                var bindingExpression = ParseBindingExpression(expressionText);
                slideInfo.BindingExpressions.Add(bindingExpression);
            }
            catch (Exception)
            {
                // Skip invalid expressions but log them in debug environments
                System.Diagnostics.Debug.WriteLine($"Skipped invalid expression: {expressionText}");
            }
        }

        // If no directives are specified but there are array indices, auto-generate directives
        if (slideInfo.Directives.Count == 0 && slideInfo.BindingExpressions.Any())
        {
            AutoGenerateDirectives(slideInfo);
        }

        // Determine slide type and additional properties
        DetermineSlideProperties(slideInfo);

        return slideInfo;
    }    /// <summary>
         /// Parses slide notes to extract directives    /// <summary>
         /// Parses slide notes to extract directives
         /// </summary>
         /// <param name="notes">The slide notes text to parse</param>
         /// <returns>List of parsed directives</returns>
    public List<Directive> ParseSlideNotes(string notes)
    {
        var directives = new List<Directive>();

        if (string.IsNullOrWhiteSpace(notes))
        {
            Logger.Debug($"ParseSlideNotes: Notes is empty or null");
            return directives;
        }

        Logger.Debug($"ParseSlideNotes: Processing notes: '{notes}'");

        // Split by lines to handle each directive properly
        var lines = notes.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(line => line.Trim())
            .Where(line => !string.IsNullOrEmpty(line) && !IsSlideNumber(line))
            .ToList();

        for (int i = 0; i < lines.Count; i++)
        {
            var line = lines[i];

            // Check if this line starts a directive
            if (!line.StartsWith("#"))
                continue;

            var match = DirectiveRegex.Match(line);
            if (!match.Success)
                continue;

            string directiveType = match.Groups[1].Value.ToLowerInvariant();
            string options = match.Groups[2].Value.Trim();

            // For alias directives, the full path might be on the next line
            if (directiveType == "alias" && string.IsNullOrWhiteSpace(options) && i + 1 < lines.Count)
            {
                // The alias specification is on the next line
                options = lines[i + 1].Trim();
                i++; // Skip the next line since we've processed it
            }

            try
            {
                var directive = ParseDirective(directiveType, options);
                if (directive != null)
                    directives.Add(directive);
            }
            catch (Exception)
            {
                // Skip invalid directives
            }
        }

        return directives;
    }

    /// <summary>
    /// Determines if a line contains only a slide number (typically at the end of notes)
    /// </summary>
    /// <param name="line">The line to check</param>
    /// <returns>True if the line appears to be just a slide number</returns>
    private static bool IsSlideNumber(string line)
    {
        // Check if the line is purely numeric (slide numbers are typically just numbers)
        return !string.IsNullOrWhiteSpace(line) && line.All(char.IsDigit);
    }

    /// <summary>
    /// Parses a specific directive based on its type and options
    /// </summary>
    /// <param name="directiveType">The type of directive (foreach, range, alias)</param>
    /// <param name="options">The directive options string</param>
    /// <returns>A parsed Directive object</returns>
    public Directive ParseDirective(string directiveType, string options)
    {
        return directiveType switch
        {
            "foreach" => ParseForeachDirective(options),
            "range" => ParseRangeDirective(options),
            "alias" => ParseAliasDirective(options),
            _ => throw new ArgumentException($"Unknown directive type: {directiveType}")
        };
    }

    /// <summary>
    /// Parses a foreach directive
    /// </summary>
    private Directive ParseForeachDirective(string options)
    {
        var match = ForeachOptionsRegex.Match(options);
        if (!match.Success)
            throw new ArgumentException($"Invalid foreach directive options: {options}");

        var directive = new Directive
        {
            Type = DirectiveType.Foreach,
            CollectionPath = match.Groups[1].Value.Trim()
        };

        if (match.Groups[2].Success && int.TryParse(match.Groups[2].Value, out int maxItems))
        {
            directive.MaxItems = maxItems;
        }

        if (match.Groups[3].Success && int.TryParse(match.Groups[3].Value, out int offset))
        {
            directive.Offset = offset;
        }

        return directive;
    }

    /// <summary>
    /// Parses a range directive
    /// </summary>
    private Directive ParseRangeDirective(string options)
    {
        var match = RangeOptionsRegex.Match(options);
        if (!match.Success)
            throw new ArgumentException($"Invalid range directive options: {options}"); var directive = new Directive
            {
                Type = DirectiveType.Range,
                CollectionPath = match.Groups[2].Value.Trim()
            };

        if (match.Groups[1].Success)
        {
            string rangeType = match.Groups[1].Value.ToLowerInvariant();
            directive.RangeBoundary = rangeType == "begin" ? RangeBoundary.Begin : RangeBoundary.End;
        }

        return directive;
    }

    /// <summary>
    /// Parses an alias directive
    /// </summary>
    private Directive ParseAliasDirective(string options)
    {
        var match = AliasOptionsRegex.Match(options);
        if (!match.Success)
            throw new ArgumentException($"Invalid alias directive options: {options}");

        return new Directive
        {
            Type = DirectiveType.Alias,
            CollectionPath = match.Groups[1].Value.Trim(),
            AliasName = match.Groups[2].Value.Trim()
        };
    }    /// <summary>
         /// Parses a binding expression string into a BindingExpression object
         /// </summary>
         /// <param name="expressionText">The expression text to parse</param>
         /// <returns>A parsed BindingExpression object</returns>
    private BindingExpression ParseBindingExpression(string expressionText)
    {
        // Extract the inner expression from ${...}
        var innerExpression = expressionText;
        if (expressionText.StartsWith("${") && expressionText.EndsWith("}"))
        {
            innerExpression = expressionText.Substring(2, expressionText.Length - 3);
        }

        var expression = new BindingExpression
        {
            OriginalExpression = expressionText,
            DataPath = innerExpression
        };        // Parse context operator (>) - Keep original for runtime processing
        var contextMatch = ContextOperatorRegex.Match(innerExpression);
        if (contextMatch.Success)
        {
            expression.UsesContextOperator = true;
            // Keep the original expression with > operator for runtime processing
            // Context-specific index substitution will happen in DataBinder
        }

        // Parse conditional expression (? :)
        var conditionalMatch = ConditionalRegex.Match(expression.DataPath);
        if (conditionalMatch.Success)
        {
            expression.IsConditional = true;
            expression.DataPath = conditionalMatch.Groups[1].Value.Trim();
        }

        // Parse method call
        var methodMatch = MethodCallRegex.Match(expression.DataPath);
        if (methodMatch.Success)
        {
            expression.IsMethodCall = true;
            expression.DataPath = methodMatch.Groups[1].Value.Trim();
        }

        // Parse format specifier (:format)
        var formatMatch = FormatSpecifierRegex.Match(expression.DataPath);
        if (formatMatch.Success && formatMatch.Groups[2].Success)
        {
            expression.DataPath = formatMatch.Groups[1].Value.Trim();
            expression.FormatSpecifier = formatMatch.Groups[2].Value.Trim();
        }        // Parse array indices using existing ArrayIndices dictionary
        var currentPath = expression.DataPath;
        var arrayMatch = ArrayIndexRegex.Match(currentPath);
        if (arrayMatch.Success)
        {
            string arrayPath = arrayMatch.Groups[1].Value.Trim();
            if (int.TryParse(arrayMatch.Groups[2].Value, out int index))
            {
                // Extract the array name (last part of the path before the index)
                string arrayName = arrayPath;
                if (arrayPath.Contains('.'))
                {
                    var parts = arrayPath.Split('.');
                    arrayName = parts[0]; // Use the first part as the collection name
                }
                else if (arrayPath.Contains('>'))
                {
                    var parts = arrayPath.Split('>');
                    arrayName = parts[0]; // Use the first part as the collection name
                }

                expression.ArrayIndices[arrayName] = index;
                // Keep the full path for data binding
                expression.DataPath = currentPath;
            }
        }

        return expression;
    }    /// <summary>
         /// Auto-generates directives for slides with array expressions but no explicit directives
         /// </summary>
    private void AutoGenerateDirectives(SlideInfo slideInfo)
    {
        var arrayExpressions = slideInfo.BindingExpressions
            .Where(expr => expr.ArrayIndices.Any())
            .GroupBy(expr => expr.ArrayIndices.Keys.First()) // Group by collection name
            .ToList();

        foreach (var group in arrayExpressions)
        {
            var collectionName = group.Key;

            // Skip invalid collection names (functions, reserved words, etc.)
            if (!IsValidCollectionDirective(collectionName))
            {
                continue;
            }

            var maxIndex = group.SelectMany(expr => expr.ArrayIndices.Values).Max();
            var directive = new Directive
            {
                Type = DirectiveType.Foreach,
                CollectionPath = collectionName,
                SourcePath = collectionName,  // ProcessForeachDirective uses SourcePath
                MaxItems = maxIndex + 1 // Convert from 0-based to count
            };

            slideInfo.Directives.Add(directive);
        }
    }

    /// <summary>
    /// Validates if a collection name should be treated as a valid collection directive
    /// </summary>
    /// <param name="collectionName">The collection name to validate</param>
    /// <returns>True if valid collection, false if function or reserved word</returns>
    private bool IsValidCollectionDirective(string collectionName)
    {
        if (string.IsNullOrWhiteSpace(collectionName))
            return false;

        // Exclude PPT functions and other reserved names
        var reservedNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "ppt",
            "PPT",
            "function",
            "method",
            "var",
            "const",
            "let"
        };

        return !reservedNames.Contains(collectionName);
    }/// <summary>
     /// Determines slide type and additional properties based on directives and expressions
     /// </summary>
    private void DetermineSlideProperties(SlideInfo slideInfo)
    {
        // Calculate max array index first
        var maxIndex = slideInfo.BindingExpressions
            .SelectMany(expr => expr.ArrayIndices.Values)
            .DefaultIfEmpty(-1)
            .Max();

        if (maxIndex >= 0)
        {
            slideInfo.MaxArrayIndex = maxIndex;
        }

        // Determine slide type
        if (slideInfo.Directives.Any(d => d.Type == DirectiveType.Range))
        {
            var rangeDirective = slideInfo.Directives.First(d => d.Type == DirectiveType.Range);
            slideInfo.Type = rangeDirective.RangeBoundary == RangeBoundary.Begin ? SlideType.Source : SlideType.Cloned;
        }
        else if (slideInfo.Directives.Any(d => d.Type == DirectiveType.Foreach) || slideInfo.HasArrayReferences)
        {
            slideInfo.Type = SlideType.Source;
        }
        else
        {
            slideInfo.Type = SlideType.Static;
        }

        // Set collection name
        var foreachDirective = slideInfo.Directives.FirstOrDefault(d => d.Type == DirectiveType.Foreach);
        if (foreachDirective != null)
        {
            slideInfo.CollectionName = foreachDirective.CollectionPath;
        }
        else if (slideInfo.HasArrayReferences)
        {
            // Get collection name from array expressions
            var arrayExpression = slideInfo.BindingExpressions.FirstOrDefault(expr => expr.ArrayIndices.Any());
            if (arrayExpression != null)
            {
                slideInfo.CollectionName = arrayExpression.ArrayIndices.Keys.First();
            }
        }
    }

    /// <summary>
    /// Generates automatic slide notes based on slide content and binding expressions
    /// </summary>
    /// <param name="slideInfo">The analyzed slide information</param>
    /// <param name="slide">The slide object to analyze content from</param>
    /// <returns>Generated slide notes content</returns>
    public string GenerateSlideNotes(SlideInfo slideInfo, object slide)
    {
        var notesBuilder = new System.Text.StringBuilder();

        // Add a header for auto-generated notes
        notesBuilder.AppendLine("# Auto-Generated Slide Notes");
        notesBuilder.AppendLine();

        // Add slide type information
        notesBuilder.AppendLine($"**Slide Type:** {slideInfo.Type}");
        notesBuilder.AppendLine();

        // Add directive information
        if (slideInfo.Directives.Any())
        {
            notesBuilder.AppendLine("**Directives:**");
            foreach (var directive in slideInfo.Directives)
            {
                switch (directive.Type)
                {
                    case DirectiveType.Foreach:
                        notesBuilder.AppendLine($"- Foreach: {directive.CollectionPath}");
                        if (directive.MaxItems > 0)
                            notesBuilder.AppendLine($"  - Max Items: {directive.MaxItems}");
                        if (directive.Offset > 0)
                            notesBuilder.AppendLine($"  - Offset: {directive.Offset}");
                        break;
                    case DirectiveType.Range:
                        notesBuilder.AppendLine($"- Range: {directive.CollectionPath} ({directive.RangeBoundary})");
                        break;
                    case DirectiveType.Alias:
                        notesBuilder.AppendLine($"- Alias: {directive.CollectionPath} as {directive.AliasName}");
                        break;
                }
            }
            notesBuilder.AppendLine();
        }

        // Add data binding information
        if (slideInfo.BindingExpressions.Any())
        {
            notesBuilder.AppendLine("**Data Bindings:**");
            var groupedExpressions = slideInfo.BindingExpressions
                .GroupBy(expr => GetDataSource(expr.DataPath))
                .OrderBy(g => g.Key);

            foreach (var group in groupedExpressions)
            {
                notesBuilder.AppendLine($"- **{group.Key}:**");
                foreach (var expression in group.OrderBy(e => e.DataPath))
                {
                    var description = GetBindingDescription(expression);
                    notesBuilder.AppendLine($"  - {expression.DataPath}: {description}");
                }
            }
            notesBuilder.AppendLine();
        }        // Add content summary
        var slideText = ExtractSlideTextDirect(slide);
        if (!string.IsNullOrWhiteSpace(slideText))
        {
            var contentSummary = GenerateContentSummary(slideText);
            if (!string.IsNullOrWhiteSpace(contentSummary))
            {
                notesBuilder.AppendLine("**Content Summary:**");
                notesBuilder.AppendLine(contentSummary);
                notesBuilder.AppendLine();
            }
        }

        return notesBuilder.ToString().Trim();
    }

    /// <summary>
    /// Direct text extraction from slide
    /// </summary>
    private string ExtractSlideTextDirect(object slide)
    {
        if (slide is SlidePart slidePart)
        {
            var textBuilder = new System.Text.StringBuilder();
            var paragraphs = slidePart.Slide.Descendants<Paragraph>();

            foreach (var paragraph in paragraphs)
            {
                var hierarchicalInfo = TextExtractionUtility.ExtractHierarchicalText(paragraph);
                var paragraphText = hierarchicalInfo.CombinedText;

                if (!string.IsNullOrEmpty(paragraphText))
                {
                    textBuilder.AppendLine(paragraphText);
                }
            }

            return textBuilder.ToString();
        }

        return string.Empty;
    }

    /// <summary>
    /// Extracts the data source from a data path
    /// </summary>
    private string GetDataSource(string dataPath)
    {
        if (string.IsNullOrWhiteSpace(dataPath))
            return "Unknown";

        // Handle context operator
        if (dataPath.Contains('>'))
        {
            var parts = dataPath.Split('>');
            return parts[0].Trim();
        }

        // Handle array access
        var arrayMatch = ArrayIndexRegex.Match(dataPath);
        if (arrayMatch.Success)
        {
            return arrayMatch.Groups[1].Value;
        }

        // Handle property access
        var dotIndex = dataPath.IndexOf('.');
        if (dotIndex > 0)
        {
            return dataPath.Substring(0, dotIndex);
        }

        return dataPath;
    }

    /// <summary>
    /// Generates a description for a binding expression
    /// </summary>
    private string GetBindingDescription(BindingExpression expression)
    {
        var dataPath = expression.DataPath;

        // Handle conditional expressions
        var conditionalMatch = ConditionalRegex.Match(dataPath);
        if (conditionalMatch.Success)
        {
            return "Conditional value display";
        }

        // Handle method calls
        var methodMatch = MethodCallRegex.Match(dataPath);
        if (methodMatch.Success)
        {
            return $"Method call result from {methodMatch.Groups[1].Value}";
        }

        // Handle array access
        var arrayMatch = ArrayIndexRegex.Match(dataPath);
        if (arrayMatch.Success)
        {
            var index = arrayMatch.Groups[2].Value;
            return $"Item #{int.Parse(index) + 1} from collection";
        }

        // Handle context operator
        if (dataPath.Contains('>'))
        {
            return "Contextual data binding";
        }

        // Handle property paths
        if (dataPath.Contains('.'))
        {
            var parts = dataPath.Split('.');
            return $"Property '{parts.Last()}' value";
        }

        return "Data value";
    }

    /// <summary>
    /// Generates a content summary based on slide text
    /// </summary>
    private string GenerateContentSummary(string slideText)
    {
        if (string.IsNullOrWhiteSpace(slideText))
            return string.Empty;

        // Remove binding expressions for summary
        var cleanText = BindingExpressionRegex.Replace(slideText, "[Data]");

        // Split into sentences and take key information
        var sentences = cleanText.Split(new[] { '.', '!', '?' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => s.Trim())
            .Where(s => !string.IsNullOrWhiteSpace(s) && s.Length > 5)
            .Take(3);

        if (!sentences.Any())
            return "Slide contains data-driven content";

        return string.Join(". ", sentences) + ".";
    }
}
