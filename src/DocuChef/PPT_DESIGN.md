# PowerPoint Template Processing Architecture

## Overview

This document describes the 4-stage processing flow for PowerPoint template handling in DocuChef. The architecture emphasizes clean separation of concerns, maintaining template integrity throughout the process, and providing robust data binding capabilities.

## Core Architecture

### Core Components

The PowerPoint template engine consists of four main processors that handle the processing flow:

- **TemplateAnalyzer**: Template analysis and SlideInfo generation
- **SlidePlanGenerator**: Slide plan generation based on template analysis and data
- **SlideGenerator**: Slide creation and expression transformation
- **DataBinder**: Data binding to expressions in generated slides

### Core Models

- **SlideInfo**: Slide ID, type (Static/Source/Cloned), directives list, binding expressions
- **SlidePlan**: List of slide instances to be generated
- **SlideInstance**: Source slide ID, type, position, context path, index offset
- **Directive**: Directive type (foreach/range/alias), collection path, options
- **BindingExpression**: Original expression, data path, array indices, format specifier

## 4-Stage Processing Flow

### Stage 1: Template Analysis (TemplateAnalyzer)

**Purpose**: Analyze PowerPoint template to extract binding expressions and control directives.

**Input**: PowerPoint template (.pptx file)
**Output**: List of `SlideInfo` objects

**Key Responsibilities**:
- Extract `${...}` binding expressions from slide content using `ExpressionExtractor`
- Parse control directives from slide notes (`#foreach`, `#range-begin`, `#range-end`, `#alias`)
- Determine slide types (Static, Source, Cloned)
- Calculate array indices and items per slide from `MaxArrayIndex`
- Generate automatic directives when not explicitly specified
- Support contextual expressions with `>` operator (e.g., `Products>Items[0].Name`)

**Implementation**:

```csharp
public SlideInfo Analyze(object slide, string slideNotes, int slideId)
{
    var slideInfo = new SlideInfo
    {
        SlideId = slideId,
        Type = SlideType.Static
    };

    // Parse directives from slide notes
    if (!string.IsNullOrEmpty(slideNotes))
    {
        slideInfo.Directives = ParseSlideNotes(slideNotes);
    }

    // Extract binding expressions from slide content using centralized extractor
    var bindingExpressions = ExpressionExtractor.ExtractExpressionsFromSlide(slide);
    var expressionsToProcess = bindingExpressions.ToList();
    
    foreach (var expressionText in expressionsToProcess)
    {
        try
        {
            var bindingExpression = ParseBindingExpression(expressionText);
            slideInfo.BindingExpressions.Add(bindingExpression);
        }
        catch (Exception)
        {
            // Skip invalid expressions but log them in debug environments
            System.Diagnostics.Debug.WriteLine($"Skipped invalid expression: {expressionText}");
        }
    }

    // Auto-generate directives if needed
    if (slideInfo.Directives.Count == 0 && slideInfo.BindingExpressions.Any())
    {
        AutoGenerateDirectives(slideInfo);
    }

    // Determine slide type and additional properties
    DetermineSlideProperties(slideInfo);

    return slideInfo;
}
```

**Key Features**:
- **Expression Extraction**: Uses `ExpressionExtractor.ExtractExpressionsFromSlide()` for centralized extraction
- **Error Handling**: Gracefully handles invalid expressions without breaking the process
- **Auto-Generation**: Creates directives automatically when not explicitly specified
- **Property Determination**: Calculates `MaxArrayIndex`, `HasArrayReferences`, and `ItemsPerSlide`

### Stage 2: Slide Plan Generation (SlidePlanGenerator)

**Purpose**: Generate a comprehensive plan for slide creation based on template analysis and data.

**Input**: List of `SlideInfo` objects, data object
**Output**: `SlidePlan` containing slide instances

**Key Responsibilities**:
- Build alias mappings for simplified path resolution
- Process nested context expressions (e.g., `Products>Items`)
- Handle range directives and foreach loops
- Calculate required slides and position sequencing
- Support nested collections and hierarchical data structures

**Implementation**:

```csharp
public SlidePlan GeneratePlan(List<SlideInfo> slideInfos, object data)
{
    if (slideInfos == null || slideInfos.Count == 0 || data == null)
        return new SlidePlan();

    var slidePlan = new SlidePlan();
    var aliasMap = BuildAliasMap(slideInfos);

    // Check if we have nested context (Products>Items pattern)
    var hasNestedContext = slideInfos.Any(si =>
        si.BindingExpressions.Any(expr => expr.DataPath.Contains(">")));

    if (hasNestedContext)
    {
        Logger.Debug("SlidePlanGenerator: Detected nested context patterns, using nested processing");
        // Process nested ranges first, then standalone slides
        ProcessNestedRangeSlides(slideInfos, slidePlan, data, aliasMap);
        ProcessStandaloneSlides(slideInfos, slidePlan, data, aliasMap);
    }
    else
    {
        // Traditional processing: range directives first, then standalone
        ProcessRangeDirectives(slideInfos, slidePlan, data, aliasMap);
        ProcessStandaloneSlides(slideInfos, slidePlan, data, aliasMap);
    }

    // Add static slides (before range-begin and after range-end)
    var staticSlides = slideInfos.Where(si => si.Type == SlideType.Static && 
        !si.Directives.Any(d => d.Type == DirectiveType.Range)).ToList();
    
    foreach (var staticSlide in staticSlides)
    {
        slidePlan.AddSlideInstance(new SlideInstance
        {
            SourceSlideId = staticSlide.SlideId,
            Position = GetNextPosition(slidePlan),
            ContextPath = new List<string>(),
            IndexOffset = 0
        });
    }

    return slidePlan;
}
```

**Key Features**:
- **Nested Context Detection**: Automatically detects `Products>Items` patterns and uses appropriate processing
- **Alias Support**: Builds and uses alias mappings for simplified expressions
- **Flexible Processing**: Handles both traditional and nested context scenarios
- **Static Slide Preservation**: Maintains static slides in their correct positions

### Stage 3: Slide Generation (SlideGenerator)

**Purpose**: Create slide instances according to the slide plan while preserving template design.

**Input**: PresentationDocument, SlidePlan, SlideInfo list, data object, alias map
**Output**: Generated slides with preserved expressions (ready for data binding)

**Key Responsibilities**:
- Clone slides from templates without modifying expressions
- Apply alias transformations using 2-stage processing
- Update expressions with correct context paths and index offsets
- Generate automatic slide notes when needed
- Remove original template slides that have been repositioned

**Implementation**:

```csharp
public void GenerateSlides(PresentationDocument presentationDocument, SlidePlan slidePlan, 
    List<SlideInfo>? slideInfos = null, object? data = null, Dictionary<string, string>? aliasMap = null)
{
    var presentationPart = presentationDocument.PresentationPart;
    ValidatePresentation(presentationDocument);

    var slideIdList = presentationPart.Presentation.SlideIdList;
    var sourceSlides = slideIdList.ChildElements.OfType<SlideId>().ToList();

    // ==== PHASE 1: Clone all slides first (preserving original expressions) ====
    var slidesToClone = new List<(SlideInstance instance, int insertPosition)>();
    var originalSlidesToRemove = new HashSet<int>();
    var originalSlidesToKeep = new HashSet<int>();
    var generatedSlides = new List<(SlidePart slidePart, SlideInstance instance)>();

    // Collect slides to clone and track originals
    foreach (var slideInstance in slidePlan.SlideInstances)
    {
        // Check if this is an original slide at its original position
        if (slideInstance.Position == slideInstance.SourceSlideId)
        {
            originalSlidesToKeep.Add(slideInstance.SourceSlideId);
            // Add original slide to processing list for Phase 2
            var originalSlideId = sourceSlides[slideInstance.SourceSlideId];
            if (originalSlideId?.RelationshipId?.Value != null)
            {
                var originalSlidePart = (SlidePart)presentationPart.GetPartById(originalSlideId.RelationshipId.Value);
                if (originalSlidePart != null)
                {
                    generatedSlides.Add((originalSlidePart, slideInstance));
                }
            }
            continue;
        }
        else
        {
            // This slide is being repositioned, so mark the original for removal
            if (!originalSlidesToKeep.Contains(slideInstance.SourceSlideId))
            {
                originalSlidesToRemove.Add(slideInstance.SourceSlideId);
            }
        }

        var insertPosition = slideInstance.Position;
        slidesToClone.Add((slideInstance, insertPosition));
    }

    // Sort by insert position to maintain correct order from slide plan
    slidesToClone.Sort((a, b) => a.insertPosition.CompareTo(b.insertPosition));

    // Clone slides without any expression modifications
    foreach (var (slideInstance, insertPosition) in slidesToClone)
    {
        // Find the template slide by index (SourceSlideId is 0-based index)
        if (slideInstance.SourceSlideId < 0 || slideInstance.SourceSlideId >= sourceSlides.Count)
        {
            Logger.Warning($"SlideGenerator: Template slide index {slideInstance.SourceSlideId} is out of range");
            continue;
        }

        var templateSlideId = sourceSlides[slideInstance.SourceSlideId];
        if (templateSlideId?.RelationshipId?.Value == null)
        {
            Logger.Warning($"SlideGenerator: Template slide at index {slideInstance.SourceSlideId} has no relationship ID");
            continue;
        }

        // Get the template slide part
        var templateSlidePart = (SlidePart)presentationPart.GetPartById(templateSlideId.RelationshipId.Value);
        if (templateSlidePart?.Slide == null)
        {
            Logger.Warning($"SlideGenerator: Template slide part for slide {slideInstance.SourceSlideId} is invalid");
            continue;
        }

        // Clone the slide WITHOUT any expression modifications
        var newSlidePart = _slideCloner.CloneSlideFromTemplate(presentationPart, templateSlidePart, insertPosition);

        if (newSlidePart != null)
        {
            // Generate auto notes if slide info is available
            var slideInfo = slideInfos?.FirstOrDefault(s => s.SlideId == slideInstance.SourceSlideId);
            if (slideInfo != null)
            {
                GenerateAutoNotesIfNeeded(newSlidePart, slideInfo);
            }

            // Add to processing list for Phase 2
            generatedSlides.Add((newSlidePart, slideInstance));
        }
    }

    // ==== PHASE 2: Apply expression corrections to all slides ====
    foreach (var (slidePart, slideInstance) in generatedSlides)
    {
        // Apply alias transformations first
        if (aliasMap != null && aliasMap.Count > 0)
        {
            ApplyAliasesToSlide(slidePart, aliasMap);
        }

        // Apply expression updates with correct context path and index offset
        var contextPathString = slideInstance.ContextPath.Count > 0 ? string.Join(">", slideInstance.ContextPath) : null;
        _expressionUpdater.UpdateExpressionsWithIndexOffset(slidePart, slideInstance.IndexOffset, data, contextPathString);
    }

    // Remove original slides that have been repositioned
    _slideRemover.RemoveOriginalSlides(presentationPart, sourceSlides, originalSlidesToRemove);
}
```

**Key Features**:
- **2-Phase Processing**: First clone slides preserving expressions, then apply corrections
- **Alias Transformation**: 2-stage alias processing for complex expressions
- **Expression Updates**: Applies context paths and index offsets correctly
- **Template Preservation**: Maintains original template design and formatting

### Stage 4: Data Binding (DataBinder)

**Purpose**: Bind actual data to expressions in generated slides.

**Input**: Generated slides with updated expressions, data object, context information
**Output**: Final presentation with data bound to expressions

**Key Responsibilities**:
- Resolve binding expressions using reflection and property paths
- Handle array indexing and contextual data access
- Apply format specifiers and type conversions
- Process special functions like `ppt.Image()`
- Manage performance through caching and optimizations

**Implementation**:

```csharp
public void BindData(SlidePart slidePart, object data, SlideContext slideContext)
{
    var slide = slidePart.Slide;
    var textElements = slide.Descendants<DocumentFormat.OpenXml.Drawing.Text>().ToList();
    
    Logger.Debug($"DataBinder: Processing {textElements.Count} text elements in slide");

    foreach (var textElement in textElements.Take(10)) // Performance optimization: limit logging
    {
        if (string.IsNullOrEmpty(textElement.Text))
            continue;

        try
        {
            var originalText = textElement.Text;
            var boundText = ProcessBindingExpression(originalText, data, slideContext);
            
            if (boundText != originalText)
            {
                textElement.Text = boundText;
                slideContext.MarkExpressionProcessed(originalText);
            }
        }
        catch (Exception ex)
        {
            Logger.Warning($"DataBinder: Failed to bind expression in text element: {ex.Message}");
        }
    }

    // Process images and other special elements
    ProcessImageBindings(slidePart, data, slideContext);
}

private string ProcessBindingExpression(string text, object data, SlideContext slideContext)
{
    var expressionPattern = new Regex(@"\$\{([^}]+)\}", RegexOptions.Compiled);
    
    return expressionPattern.Replace(text, match =>
    {
        var expression = match.Groups[1].Value;
        try
        {
            var resolvedValue = ResolveExpression(expression, data, slideContext);
            return FormatValue(resolvedValue, expression);
        }
        catch (Exception ex)
        {
            Logger.Warning($"DataBinder: Failed to resolve expression '{expression}': {ex.Message}");
            return match.Value; // Return original expression if resolution fails
        }
    });
}
```

**Key Features**:
- **Performance Optimization**: Uses caching for PropertyInfo and frequently accessed data
- **Error Resilience**: Graceful handling of binding failures without breaking the process
- **Format Support**: Handles format specifiers and type conversions
- **Context Awareness**: Supports contextual data access with `>` operator
- **Special Functions**: Processes `ppt.Image()` and other specialized functions

## Core Model Details

### SlideInfo

```csharp
public class SlideInfo
{
    public int SlideId { get; set; }
    public SlideType Type { get; set; }
    public int Position { get; set; }
    public string? CollectionName { get; set; }
    public List<Directive> Directives { get; set; } = new List<Directive>();
    public List<BindingExpression> BindingExpressions { get; set; } = new List<BindingExpression>();
    public int MaxArrayIndex { get; set; } = -1;
    public bool HasArrayReferences => MaxArrayIndex >= 0;
    public int ItemsPerSlide => MaxArrayIndex + 1;
}

public enum SlideType
{
    Static,   // Static slide with no data binding
    Source,   // Source slide that will be cloned for collections
    Cloned    // Cloned slide generated from source
}
```

### SlidePlan and SlideInstance

```csharp
public class SlidePlan
{
    public List<SlideInstance> SlideInstances { get; set; } = new List<SlideInstance>();
    public Dictionary<string, string> Aliases { get; set; } = new Dictionary<string, string>();
    public Dictionary<string, List<string>> ContextChains { get; set; } = new Dictionary<string, List<string>>();
    public int TotalSlideCount => SlideInstances.Count;
}

public class SlideInstance
{
    public int SourceSlideId { get; set; }
    public SlideInstanceType Type { get; set; }
    public int Position { get; set; }
    public List<string> ContextPath { get; set; } = new List<string>();
    public int IndexOffset { get; set; }
    public string? CollectionName { get; set; }
    public int StartIndex { get; set; }
    public int ItemsPerSlide { get; set; }
    public bool IsEmpty { get; set; }
    public int? ParentIndex { get; set; }
    public string ContextPathString => string.Join(">", ContextPath);
}

public enum SlideInstanceType
{
    Static,    // Static slide with no data binding
    Generated  // Generated slide from template processing
}
```

### Directive and BindingExpression

```csharp
public class Directive
{
    public DirectiveType Type { get; set; }
    public string SourcePath { get; set; } = string.Empty;
    public string CollectionPath { get; set; } = string.Empty;
    public int MaxItems { get; set; }
    public int Offset { get; set; }
    public string? AliasName { get; set; }
    public RangeBoundary? RangeBoundary { get; set; }
}

public class BindingExpression
{
    public string OriginalExpression { get; set; } = string.Empty;
    public string DataPath { get; set; } = string.Empty;
    public Dictionary<string, int> ArrayIndices { get; set; } = new Dictionary<string, int>();
    public string? FormatSpecifier { get; set; }
    public bool IsContextualExpression => DataPath.Contains(">");
    public bool IsArrayExpression => ArrayIndices.Any();
}
```

## Directive Syntax

### #foreach Directive
```
#foreach: CollectionName, max: ItemsPerSlide, offset: StartingIndex
```
- **CollectionName**: Path to the collection data (required)
- **max**: Maximum items per slide (optional, default: auto-detect from expressions)
- **offset**: Starting index offset (optional, default: 0)

### #range Directive
```
#range-begin: CollectionName
#range-end: CollectionName
```
- Defines a range of slides that should be processed together
- All slides between begin and end are treated as a group

### #alias Directive
```
#alias: FullPath as ShortName
```
- Creates a short alias for complex paths
- Example: `#alias: Company.Departments.Employees as Staff`

## Expression Syntax

### Basic Value Binding
```
${PropertyName}                     // Simple property
${Object.PropertyName}              // Nested property
${Array[0].PropertyName}            // Array element property
${Value:FormatSpecifier}            // With format specifier
```

### Contextual Expressions
```
${Parent>Child.PropertyName}              // Context operator
${Categories>Items[0].Name}               // Array in context
${Departments>Teams[0]>Members[2].Name}   // Nested context
```

### Special Functions
```
${ppt.Image("ImageProperty")}                    // Image binding
${ppt.Image("Product.Photo", width: 300, height: 200, preserveAspectRatio: true)}
```

## Performance Optimizations

### Caching Strategy
- **PropertyInfo Caching**: Reflection results cached per DataBinder instance
- **Expression Parsing**: Compiled regex patterns for better performance
- **Array Access**: Optimized array index parsing with `TryParseArrayAccess`

### Memory Management
- **Instance-based Caching**: Avoids static memory leaks
- **Bounded Collections**: Limits processing for large datasets
- **Disposal Patterns**: Proper cleanup of resources

### Error Handling
- **Graceful Degradation**: Invalid expressions don't break the entire process
- **Detailed Logging**: Comprehensive debugging information
- **Exception Categorization**: Different handling for different error types

## Best Practices

### Template Design
1. **Design-First Approach**: Focus on PowerPoint design, then add data binding
2. **Consistent Patterns**: Use consistent array indexing patterns
3. **Clear Structure**: Organize slides logically with proper directives

### Expression Writing
1. **Simple Paths**: Keep data paths as simple as possible
2. **Context Usage**: Use `>` operator for nested collections
3. **Format Specifiers**: Apply formatting at expression level

### Performance Considerations
1. **Limit Expressions**: Avoid excessive binding expressions per slide
2. **Cache Data**: Prepare data in optimal structure for binding
3. **Template Size**: Keep template complexity reasonable

## Troubleshooting

### Common Issues
1. **Missing Data**: Check data structure matches expression paths
2. **Array Index Errors**: Verify array indices don't exceed data bounds
3. **Context Problems**: Ensure context paths are correctly structured
4. **Performance Issues**: Review expression complexity and data size

### Debugging Tools
1. **Logging**: Enable debug logging for detailed processing information
2. **Expression Validation**: Use expression parsing methods to validate syntax
3. **Data Inspection**: Check resolved data at each stage of processing
